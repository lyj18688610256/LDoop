.comp Flow{

    .decl exist(?var:Ctx_Var)
    .output exist
    .decl SmallVFlow(?from:Ctx_Var, ?to:Ctx_Var)
    .output SmallVFlow

    .decl SourceValue(?Ctx_Invocation:Ctx_Var, ?var:Ctx_Var)
    .output SourceValue
    .decl SinkValue(?var:Ctx_Var, ?Ctx_SinkInvocation:Ctx_Var)
    .output SinkValue
    .type Ctx_Var = [ctx:Context, var:Var]
    .type List = [
        tail : List,
        head : Ctx_Var
    ]
    .type SList =[
        tail : SList,
        head : Var
    ]
    
    .decl B(x : List)
    .output B
    .limitsize B(n=10)

    .decl C(x : List)
    .output C
    .limitsize C(n=10)

SinkValue(?from_Ctx_Var, ?to_Ctx_Var):-
    LeakingSinkVariable(_, ?invocation, ?ctx, ?var),
    ?from_Ctx_Var = [?ctx, ?var],
    ?to_Ctx_Var = [?ctx, ?invocation].

    
SmallVFlow(?from_Ctx_Var, ?to_Ctx_Var):-
    mainAnalysis.LyjSmallVFlow(?from_Ctx, ?from, ?to_Ctx, ?to),
    ?from_Ctx_Var = [?from_Ctx, ?from],
    ?to_Ctx_Var = [?to_Ctx, ?to].
    
    B(r3) :- 
        B(r1),SmallVFlow(b,c),r1=[r2,b],r3=[r1,c].
    C(r31) :- B(r11),r11=[r21,b],SinkValue(b,c),r31=[r11,c].
    
    B([[nil,?a],?b]) :-  //定义这条链路的前两个元素
        SourceValue(?a, ?b),
        ?a = [?ctx1, ?var1],
        ?b = [?ctx2, ?var2].

}